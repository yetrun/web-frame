# 使用教程

## 定义 API 模块

`Dain::Application` 定义了一个 API 模块，通过继承的方法定义。

```ruby
require 'dain'

class NotesAPI < Dain::Application
  route('/notes', :post)
    .title('创建新的笔记')
    .params {
      param :note, type: 'object', using: NoteEntity
    }
    .do_any {
      note = Note.create!(params[:note])
      render({ 'note' => note }, { scope: 'full' })
    }
    .if_status(201) {
      expose :note, type: 'object', using: NoteEntity
    }
end
```

在模块内部，使用 `route` 宏语句定义接口。上例中，`route('/notes', :post)` 定义了一个 `POST /notes` 的 API，类似地可定义：

- 查看笔记列表：`route('/notes', :get)`;

- 查看笔记详情：`route('/notes', :get)`;

- 更新笔记：`route('/notes/:id', :put)`;

- 删除笔记：`route('/notes/:id', :delete)`.

`route(...)` 返回一个 `Route` 对象，它通过一系列的链式调用定义该路由的其他语义。以下列举 `Route` 对象可定义的语义：

- `.title`：定义标题。

- `.params`：定义参数。

- `.if_status`：定义响应码和返回内容。

- `.resource`：定义资源。

- `.authorize`：权限验证，类似于 Pundit.

- `.do_any`：你的业务逻辑应该写在此处。

这里解释一下 `.resource` 宏和 `.authorize` 宏。

### `.resource` 宏

`.resource` 宏接受一个块语句，它返回资源的实体。注意如果返回值是个 `nil` 则会抛出 `Dain::Errors::NotFound`.

```ruby
route('/users/:id', :get)
  .resource { 
    # 如果返回 nil 则会抛出异常
    User.find_by(id: params[:id])
  }
  .do_any {
    # 后续可以通过 `resource` 方法访问
    p resource
  }
```

### `.authorize` 宏

`.authorize` 宏接受一个块语句，它返回 `true` 或 `false` 已确定是否通过权限验证。

```ruby
route('/users', :get)
  .do_any {
    token = request.headers['X-Token']
    @current_user = User.find_by_token(token)
  }
  .authorize { @current_user.admin? }
```

### `.set_status` 和 `.if_status`

`.set_status` 宏用来设置状态码。它接受一个块，块执行结果即为待设置的状态码。

```ruby
.set_status { 204 }
```

`.if_status` 前面讲过，用来设置状态码的响应内容。

```ruby
.if_status(200) {
  # 定义实体内容
}
.if_status(400) {
  # 定义报错信息
}
```

### 嵌套路由

以下是嵌套路由的一个用法：

```ruby
route('/notes/:id')
  .resource { Note.find(params[:id]) }
  .nesting do |route|
    route.method(:get)
      .title('获取笔记详情')
      .do_any {
        render('note' => resource) 
      }

    route.method(:get)
      .title('更新笔记')
      .do_any {
        resource.update!(params)
        render('note' => resource) 
      }

    route.method(:delete)
      .title('删除笔记')
      .do_any {
        resource.destroy
      }
  end
```

定义嵌套路由主要是考虑有一些公共的逻辑需要提取出来，比如上例的 `.resource`.

关于路由定义的更多用法参考[路由定义的更多用法.md](路由定义的更多用法.md).

### 模块重用

`Dain::Application` 模块是可以被重用的，使用 `apply`宏即可应用预定义的模块。 

```ruby
class GlobalApp < Dain::Application
  apply API::Notes
  apply API::Users
end
```

上例中的 `API::Notes` 和 `API::Users` 也是一个 `Dain::Application` 模块。

```ruby
class API::Notes < Dain::Application
  # ...
end

class API::Users < Dain::Application
  # ...
end
```

### `render` 方法

render 方法可以取代 `response.body = [...]`  的调用：

```ruby
route.method(:delete)
  .title('删除笔记')
  .do_any {
    # 完整地渲染响应内容
    render({ 'users' => [...], 'count' => 100 }, { scope: 'full' })

    # 根据键值对应地渲染
    render :users, [...], { scope: 'full' }
    render :count, 100
  }
```

## 参数和响应值

首先，我们明确，定义参数和响应的宏分别是：`.params` 和 `.if_status`.

```ruby
route(...)
  .params {
    # 定义参数
  }
  .if_status(201) {
    # 定义响应内容
  }
  .if_status(400) {
    # 定义响应内容
  }
  .if_status(401) {
    # 定义响应内容
  }
```

其次，我们明确，`.params` 和 `.if_status` 宏内使用的语法是一致的。所以我们把它们放在一起统一讲。

### `params` 方法

定义 `.params` 宏后，可以在执行时调用 `params` 方法。

```ruby
route(...)
  .params {
    property :foo
    proporty :bar
  }
  .do_any {
    # 打印 `{ foo: 'foo', bar: nil }`，这种模式适用于 `PUT` 接口。
    p params
    # 打印 `{ foo: 'foo' }`，这种模式适用于 `PATCH` 接口。
    p params(:discard_missing)
    # 打印 `{ 'foo' => 'foo', 'tar' => 'tar' }`，注意键值乃字符串，
    # 返回原始参数格式。
    p params(:raw)
  }
```

以上，共有三种调用 `params` 的方式。假如此时客户端传递的参数是 `{ 'foo' => 'foo', 'tar' => 'tar' }`，则三种调用方式打印的内容由注释给出。

### 定义实体

#### 定义对象

`.params` 宏如果带一个块，则它接受的是一个对象实体定义。在块的内部，用 `property` 宏定义属性。

```ruby
.params {
  property :foo, type: 'string', desc: '属性 foo'
  property :bar, type: 'integer', desc: '属性 bar'
}
```

#### 嵌套定义

实体内部可定义嵌套对象属性：

```ruby
.params {
  property :user do
    property :name, type: 'string', desc: '姓名'
    property :age, type: 'integer', desc: '年龄'
  end
}
```

亦可定义一个数组：

```ruby
.params {
  property :user_ids, type: 'array', items: { type: 'integer' }
}
```

亦可嵌套定义一个数组：

```ruby
.params {
  property :users, type: 'array' do
    property :name, type: 'string', desc: '姓名'
    property :age, type: 'integer', desc: '年龄'
  end
}
```

虽然我一直鼓励用上述的方法定义 API，但仍然可以实现将上述定义摘掉最外面一层的效果。第一个示例摘掉后即普通的对象定义，第二个、第三个例子摘掉后可看到定义标量数组和对象数组的效果。

#### 定义对象数组

```ruby
.params(type: 'array') {
  property :name, type: 'string', desc: '姓名'
  property :age, type: 'integer', desc: '年龄'
}
```

#### 定义标量数组

```ruby
.params(type: 'array', items: { type: 'integer' })
```

#### 定义标量

虽然极少见，但仍然可以定义标量参数。例如下述定义只接受 JSON 表示为 `5`、`7`、`9` 这样的数字格式。

```ruby
params(type: 'integer')
```

### 研究 `property` 宏

`property` 宏定义对象实体的属性，其包含曼多选项，常见选项列表：

- `type` 定义类型。

- `desc` 定义属性的描述。

- `param` 定义只属于参数范畴的选项。

- `render` 定义只属于响应值范畴的选项。

- `scope` 定义作用域范围。

- `convert` 自定义值转换。

- `value` 自定义值渲染。

#### 定义类型有什么作用

`type` 选项用来定义类型，定义类型之后参数接收和实体渲染都会尝试作类型转换，转换不成功情况下才会抛出异常。一共可定义以下几种类型：

- `boolean`
- `integer`
- `number`
- `string`
- `object`
- `array`

#### 如何定义只作为参数或返回值的属性

设置 `param: false` 则该属性不作为参数，设置 `render: false` 则该属性不作为响应被渲染。

```ruby
property :id, param: false        # ID 不作为参数
property :name, type: 'string'    # name 可作为参数，亦可作为响应值
property :password, render: false # password 不作为响应值被渲染
```

除了给 `param` 和 `render` 设置 `false` 之外，还可为它们传递专属属性。虽然我不知道下面的设定有什么作用，但它确实定义了属性 `foo` 作为参数时类型为 `string`，作为渲染时类型为 `number`.

```ruby
property :foo, param: { type: 'string' }, render: { type: 'number'}
```

#### 如何指定某些属性只在特定类的接口内显示

假如我们有一个 Note 的实体定义（怎么这里就使用了 `Dain::Entity` 实体定义？我还没介绍呢）

```ruby
class NoteEntity < Dain::Entity
  property :title
  property :content
end
```

然后有两个接口：*返回笔记列表* 和 *返回笔记详情*。

```ruby
route('/notes', :get)
  .do_any {
    notes = Note.all
    render('notes' => notes)
  }
  .if_status(200) {
    property :notes, type: 'array', using: NoteEntity
  }

route('/notes/:id', :get)
  .do_any {
    note = Note.find(params[:id])
    render({ 'note' => note }, scope: 'full')
  }
  .if_status(200) {
    property :note, using: NoteEntity
  }
```

现在我们希望只在 *返回笔记详情* 的接口返回 `content` 字段，该怎么做呢？像下面这样定义 `content` 属性即可：

```ruby
property :content, render: { scope: 'full' }
```

它表示 `content` 属性在 `render` 阶段只接受作用域为 `full` 的调用，正如 `GET /notes/:id` 接口调用的那样。注意一定要在 `render` 选项内设置，否则作为参数传递时不会被接受。

#### 自定义获取值的代码

你可以自定义获取值的动作，例如：

```ruby
property :foo, render: { value: -> { 'foo' } }
```

正常情况下我们要为属性值在实际调用时使用别名或组合，这时候需要引用到父级对象。例如下面的接口：

```ruby
route('/user', :get)
  .if_status(200) {
    property: user do
      property :name, value: -> { |user|
        "#{user['first_name']} #{user['last_name']}"
      }
    end
  }
```

有时候需要借助执行环境，例如从 `resource` 方法中获取值：

```ruby
route('/user', :get)
  .resource { User.first }
  .if_status(200) {
    property: user do
      property :datetime, value: -> { resource.created_at }
    end
  }
```

### 属性校验器

定义属性时，内置一些验证器可使用。例如日期参数可用 `format` 校验器定义：

```ruby
property :date, type: 'string', format: /\d\d\d\d-\d\d-\d\d/
```

完整的校验器列表可参考[属性校验器](属性校验器.md).

### 定义可复用的实体

通过继承 `Dain::Entity` 可定义复用的实体，在 `property` 中通过 `using` 选项使用它：

```ruby
# 定义 User 实体
class UserEntity < Dain::Entity
  property :name
  property :age
end

# 在路由中引用
property :author, using: UserEntity
```

## 错误捕获

前面提到 `.resource` 宏和 `.authorize`  宏会抛出错误，是因为 `Dain::Application` 提供了一个错误捕获机制。在模块内使用 `rescue_error` 宏即可全局地捕获异常：

```ruby
class MyApp < Dain::Application
  rescue_error Dain::Errors::NotFound do
    response.status = 400
    response.body = ['资源不存在']
  end

  rescue_error Dain::Errors::NotAuthorized do
    response.status = 403
    response.body = ['访问被禁止']
  end

  apply API::Notes
  apply API::Users
end
```

完整的错误列表包括：

- `Dain::Errors::NoMatchingRoute`

- `Dain::Errors::ParameterInvalid`

- `Dain::Errors::RenderingInvalid`

- `Dain::Errors::NotAuthorized`

- `Dain::Errors::NotFound`
